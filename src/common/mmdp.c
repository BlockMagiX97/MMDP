/* get endian */
#include <arpa/inet.h>
/* perror */
#include <errno.h>
/* printf */
#include <stdio.h>
#include <stdlib.h>
/* read, write */
#include <unistd.h>
/* assert */
#include <assert.h>

#include <common/mmdp_macro_utils.h>
#include <common/mmdp.h>
#include <common/string_helper.h>
#include <common/log-helpers.h>


#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) ||          \
    defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
/* It's a big-endian target architecture */
void swap_bytes_little(void *pv, size_t n) {
	/* already big-endian do nothing */
	return;
}
#elif defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) ||  \
    defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__)
/* It's a little-endian target architecture */
void swap_bytes_little(void *pv, size_t n) {
	char tmp, *p;
	size_t lo, hi;

	assert(n > 0);
	p = pv;
	for (lo = 0, hi = n - 1; hi > lo; lo++, hi--) {
		tmp = p[lo];
		p[lo] = p[hi];
		p[hi] = tmp;
	}
}
#else
#error "FATAL: Unable to get endianness of a machine"
#endif

struct mmdp_capability mmdp_capability;
/* limits for packet size before and after establishing connection */
uint32_t hard_limit_pre_conn = 1024;	     /* 1kB */
uint32_t hard_limit_post_conn = 1024 * 1024; /* 1MB */

/* wrappers so we can implement TLS */
ssize_t mmdp_read(void *buf, size_t count, void *read_context) {
	size_t log;
	int *fd = (int*)read_context;
	if ((log = read(*fd, buf, count)) == count) {
		printf("mmdp_read count: %lu\n", log);
		printf("mmdp_read supposed: %lu\n", count);
		return 0;
	}

	printf("mmdp_read count: %lu\n", log);
	printf("mmdp_read supposed: %lu\n", count);
	return -1;
}
ssize_t mmdp_write(void *buf, size_t count, void *write_context) {
	size_t log;
	int *fd = (int*)write_context;
	if ((log = write(*fd, buf, count)) == count) {
		printf("mmdp_write count: %lu\n", log);
		printf("mmdp_write supposed: %lu\n", count);
		return 0;
	}
	printf("mmdp_write count: %lu\n", log);
	printf("mmdp_write supposed: %lu\n", count);
	return -1;
}

int mmdp_field_type_qsort_compar(const void *x, const void *y) {
	/* we use this so we dont have to waste another 16 bytes*/
	return ((struct mmdp_field *)x)->type - ((struct mmdp_field *)y)->type;
}

void print_capability(struct mmdp_capability *cap) {
	struct mmdp_struct *c_struct;
	struct mmdp_field *c_field;
	uint32_t i;
	for (c_struct = cap->mmdp_structs; c_struct < (cap->mmdp_structs + cap->mmdp_struct_num); c_struct++) {
		printf("%s (ess: %hx):\n", c_struct->net_name, c_struct->flags);
		for (c_field = c_struct->fields; c_field < c_struct->fields + c_struct->fields_num; c_field++) {

			printf("\t%s (type: %hx, off: %lu) flags: ", c_field->net_name, c_field->type, c_field->offset);
			print_b8(c_field->flags);
			switch (c_field->type) {
			case MMDP_NORMAL:
				printf("\t\tsize: %u\n", c_field->body.normal.size);
				break;
			case MMDP_STRUCT:
				printf("\t\tid: %d\n", c_field->body.struc.id);
				break;
			case MMDP_ARRAY:
				printf("\t\tdep: %s,  size: %u\n",
				       c_struct->fields[c_field->body.array.depends_id].net_name,
				       c_field->body.array.size);
				break;
			case MMDP_STRUCT_ARRAY:
				printf("\t\tid: %d, dep: %s\n", c_field->body.struct_array.id,
				       c_struct->fields[c_field->body.struct_array.depends_id].net_name);
				break;
			}
		}
	}
	for (i = 0; i < cap->custom_struct_num; i++) {
		printf("custom: %s\n", cap->custom_structs->net_name);
	}
}

/* free the capability generated by generate_capability */
void free_capability(struct mmdp_capability *cap) {
	uint32_t i;
	for (i = 0; i < cap->mmdp_struct_num; i++) {
		free(cap->mmdp_structs[i].fields);
		cap->mmdp_structs[i].fields = NULL;
	}
	free(cap->mmdp_structs);
	cap->mmdp_structs = NULL;
	free(cap->custom_structs);
	cap->custom_structs = NULL;
	return;
}

/* free the capability received over the network */
void free_capability_heap(struct mmdp_capability *cap) {
	struct mmdp_struct *curr_struct;
	struct mmdp_field *curr_field;
	for (curr_struct = cap->mmdp_structs; curr_struct < cap->mmdp_structs + cap->mmdp_struct_num; curr_struct++) {
		for (curr_field = curr_struct->fields; curr_field < curr_struct->fields + curr_struct->fields_num;
		     curr_field++) {
			free((void *)curr_field->net_name);
			curr_field->net_name = NULL;
		}
		free((void *)curr_struct->net_name);
		curr_struct->net_name = NULL;
		free(curr_struct->fields);
		curr_struct->fields = NULL;
	}
	free(cap->mmdp_structs);
	cap->mmdp_structs = NULL;
	free(cap->custom_structs);
	cap->custom_structs = NULL;
	return;
}

/* throws compiler error if you try to use anything other then normal for depends_on */
#define _MMDP_MAKE_FIELD_ID_ENUM_MMDP_STRUCT(var_name, parent_struct)
#define _MMDP_MAKE_FIELD_ID_ENUM_MMDP_STRUCT_ARRAY(var_name, parent_struct)
#define _MMDP_MAKE_FIELD_ID_ENUM_MMDP_ARRAY(var_name, parent_struct)
#define _MMDP_MAKE_FIELD_ID_ENUM_MMDP_NORMAL(var_name, parent_struct) \
	MMDP_FIELD_ID_NORM_##parent_struct##_##var_name ,

#define _MMDP_MAKE_FIELD_ID_ENUM(_type, _flags, keyword, var_type, var_name, net_id, depends_on, parent_struct) \
	_MMDP_MAKE_FIELD_ID_ENUM_##_type(var_name, parent_struct)

#define MMDP_MAKE_FIELD_ID_ENUM(struct_name, _, __) \
	enum mmdp_field_id_norm_##struct_name { \
		MMDP_FIELDS_##struct_name(_MMDP_MAKE_FIELD_ID_ENUM, struct_name) \
		MMDP_COUNT_FIELD_ID_NORM##struct_name \
	};
/* printf */
#define MMDP_FILOUT_CAP_FIELD(_type, _flags, keyword, var_type, var_name, net_id, depends_on, parent_struct) \
	mmdp_capability.mmdp_structs[i].fields[j].net_name = net_id ; \
	mmdp_capability.mmdp_structs[i].fields[j].type = _type ; \
	mmdp_capability.mmdp_structs[i].fields[j].flags = _flags ; \
	mmdp_capability.mmdp_structs[i].fields[j].offset = offsetof(struct parent_struct, var_name ); \
	MMDP_FILOUT_CAP_FIELD_##_type(keyword, var_type, var_name, depends_on, parent_struct) \
	j++;

#define MMDP_FILOUT_CAP_FIELD_MMDP_NORMAL(keyword, var_type, var_name, depends_on, parent_struct) \
	mmdp_capability.mmdp_structs[i].fields[j].body.normal.size = sizeof( var_type );

#define MMDP_FILOUT_CAP_FIELD_MMDP_STRUCT(keyword, var_type, var_name, depends_on, parent_struct) \
	mmdp_capability.mmdp_structs[i].fields[j].body.struc.id = MMDP_##var_type ;

#define MMDP_FILOUT_CAP_FIELD_MMDP_ARRAY(keyword, var_type, var_name, depends_on, parent_struct) \
	mmdp_capability.mmdp_structs[i].fields[j].body.array.depends_id = MMDP_FIELD_ID_NORM_##parent_struct##_##depends_on ; \
	mmdp_capability.mmdp_structs[i].fields[j].body.array.size = sizeof( var_type ) ;

#define MMDP_FILOUT_CAP_FIELD_MMDP_STRUCT_ARRAY(keyword, var_type, var_name, depends_on, parent_struct) \
	mmdp_capability.mmdp_structs[i].fields[j].body.struct_array.depends_id = MMDP_FIELD_ID_NORM_##parent_struct##_##depends_on ; \
	mmdp_capability.mmdp_structs[i].fields[j].body.struct_array.id = MMDP_##var_type;

#define MMDP_FILOUT_CAP_STRUCT(struct_name, is_essential, net_id) \
	mmdp_capability.mmdp_structs[i]._size = sizeof( struct struct_name ); \
	mmdp_capability.mmdp_structs[i].net_name = net_id ; \
	mmdp_capability.mmdp_structs[i].flags = is_essential ; \
	COUNT_2(MMDP_FIELDS_##struct_name, 8, struct_name) ; \
	mmdp_capability.mmdp_structs[i].fields_num = macro_count; \
	assert(mmdp_capability.mmdp_structs[i].fields_num > 0); \
	mmdp_capability.mmdp_structs[i].fields = malloc(macro_count*sizeof(struct mmdp_field)); \
	if (mmdp_capability.mmdp_structs[i].fields == NULL) { \
		perror("malloc"); \
		while (i>0) { \
			i--; \
			free(mmdp_capability.mmdp_structs[i].fields); \
			mmdp_capability.mmdp_structs[i].fields = NULL; \
		} \
		return -1; \
	} \
	j=0; \
	MMDP_FIELDS_##struct_name(MMDP_FILOUT_CAP_FIELD , struct_name) \
	i++;

#define MMDP_FILLOUT_CAP_CUST_STRUCT(keyword, name, is_essential, net_id, _sizeof_func, _ser_func, _deser_func,        \
				     _free_func) \
	mmdp_capability.custom_structs[i]._size = sizeof(keyword name); \
	mmdp_capability.custom_structs[i].net_name = net_id; \
	mmdp_capability.custom_structs[i].sizeof_func = _sizeof_func; \
	mmdp_capability.custom_structs[i].ser_func = _ser_func; \
	mmdp_capability.custom_structs[i].deser_func = _deser_func; \
	mmdp_capability.custom_structs[i].free_func = _free_func; \
	i++;

int generate_capability() {
	uint32_t macro_count;
	uint32_t i, j;
	MMDP_STRUCTS(MMDP_MAKE_FIELD_ID_ENUM)

	COUNT_1(MMDP_CUSTOM_STRUCTS, 8);
	mmdp_capability.custom_struct_num = macro_count;
	mmdp_capability.custom_structs = malloc(sizeof(struct mmdp_custom_struct) * macro_count);
	if (mmdp_capability.custom_structs == NULL) {
		perror("malloc");
		return -1;
	}
	i = 0;
	MMDP_CUSTOM_STRUCTS(MMDP_FILLOUT_CAP_CUST_STRUCT);

	COUNT_1(MMDP_STRUCTS, 3);
	mmdp_capability.mmdp_struct_num = macro_count;

	mmdp_capability.mmdp_structs = malloc(mmdp_capability.mmdp_struct_num * sizeof(struct mmdp_struct));
	if (mmdp_capability.mmdp_structs == NULL) {
		perror("malloc");
		return -1;
	}
	i = 0;
	MMDP_STRUCTS(MMDP_FILOUT_CAP_STRUCT);

	/* sort it so that normal fields always go first */
	for (i = 0; i < mmdp_capability.mmdp_struct_num; i++) {
		qsort(mmdp_capability.mmdp_structs[i].fields, mmdp_capability.mmdp_structs[i].fields_num,
		      sizeof(struct mmdp_field), &mmdp_field_type_qsort_compar);
	}
#ifdef DEBUG
	print_capability(&mmdp_capability);
#endif
	return 0;
}

/* is NOT thread-safe */
int init_mmdp_lib() {
	if (generate_capability() != 0) {
		printf("MMDP: Unable to generate format\n");
		return -1;
	}
	return 0;
}
